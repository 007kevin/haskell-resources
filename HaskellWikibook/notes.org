* Variables & Functions
  - Haskell variables are immutable
  - where :: when defining a function and want to define results that are
             local to the function
             #+BEGIN_SRC haskell
               heron a b c = sqrt (s * (s - a) * (s - b) * (s - c))
                 where
                   s = (a + b + c) / 2
             #+END_SRC
* Truth values
  - infix operators can be written as functions using brackes. The following
    expressions are equivalent
    #+BEGIN_SRC haskell
      4 + 9 === 13
      (==) (4 + 9) 13
    #+END_SRC
  - *in general, tangible things in Haskell are either values or functions*
** Guards
   syntactic sugar that relies on booleans values to write simple but powerful
   functions
   
   To define absolute value function:
   #+BEGIN_SRC haskell
     absolute x
       | x < 0     = 0 - x
       | otherwise = x
   #+END_SRC

   guards begin with a pipe character followed by a boolean expression followed
   by the rest of the definition.

   *Note* there is no syntactical magic begin 'otherwise'. It is defined
   alonside the default variables and functions of Haskell as
   #+BEGIN_SRC haskell
     otherwise = True
   #+END_SRC

** where and guards
   where clause works with guards.
   Consider a function which computes the number of (real) solutions for
   the quadratic equation
   #+BEGIN_SRC haskell
     numOfRealSolutions a b c
      | disc > 0  = 2
      | disc == 0 = 1
      | otherwise = 0
          where
          disc = b^2 - 4*a*c
   #+END_SRC
             
* Type basics
  - All types names in Haskell must begin with a capital letter
  - All variables in Haskell must begin with a lower case letter
  - :type :: to check the type of any expression

** Functional types
   Consider two things when figuring out a type of a function
   
   1) the type of values it takes as its input
   2) the type of values it returns
      
   Thus the description of a function's type is in terms of the types of
   argument(s) it takes and the type of value it evaluates to
      
* Lists and tuples
** Lists
  Haskell builds all lists by consing all elements to the empty list.
  [1,2,3,4,5] is equivalent to 1:2:3:4:5:[]

  the cons operator (:) must have a list as its second argument and
  all elements of the list must be of same type
** Tuples
   Tuples offer another way of storing multiple values in a single value.
   Key differences between tuples and lists:
   - Tuples have a fixed number of elements (immutable); you cannot cons a tuple.
     Makes sense to use tuples when knowing in advance how many values are to be stored.
     (i.e 2D coordinates of a point)
   - Elements of tuples need not be all of the same type.

     nomenclature: in general use n-tuple to denote a tuple of size n. 2-tuples are called pairs,
     3-tuples called triples, quadruples, quintuples, etc.

     tuples are handy when wanting to return more than one value froma function. 

     The type of a tuple is defined not only by its size but also the type of objects it contains. 
     For example, ("Hello", 32) and (47,"World") are fundamentally different since one is
     (String, Int) whereas other (Int, String). This difference in types means they cannot
     be put into a list.

** Retrieving values
   Standard functions for retrieving values from tuples (works only on pairs):
   fst :: (a,b) -> a
   snd :: (a,b) -> b

   Standard functions for retrieving values from lists):
   head :: [a] -> a
   tail :: [a] -> [a] -- get the list after the first value

   *Note* attempting to run head or tail on the empty list will crash a program

* Simple input and output
  '<-' can be used with any action except the last
  Q: Why can't we get a value out of the final action of a do block?
  A: Without getting too deep, suffice to say you use <- to get the
     value of an action, and Haskell is always expecting another action
     to follow it
  
  #+BEGIN_SRC haskell
    :t putStrLn
      putStrLn :: String -> IO ()
  #+END_SRC
     *Type of putStrLn takes a String parameter and returns*
     *an IO action that when run returns the () value.*

  #+BEGIN_SRC haskell
    :t getLine
      getLine :: IO String
  #+END_SRC
     *Type of getLIne take no input paramter and returns*
     *an action that when run returns a String*

  Within a 'do block', each line runs the actions in which
  the returned value can be assigned via <-

  You can't use actions in situations that don't call for them.
  For the converse, you can use non-actions in situations that
  expect actions.
     
  For situations calling for non-actions to be used in actions,
  one can use the 'return' code or 'let' binding.

  _let bindings in do blocks_
  #+BEGIN_SRC haskell
main =
 do name <- getLine
    let loudName = makeLoud name
    putStrLn ("Hello " ++ loudName ++ "!")
    putStrLn ("Oh boy! Am I excited to meet you, " ++ loudName)
  #+END_SRC
  
  notice the let binding above is missing an in. This is because
  let bindings inside do blocks do not (optionally )require the 
  in keyword.
* Recursion
* Lists II
  - The -> in type signatures is right associative. This means one
    can read the this signature
    #+BEGIN_SRC haskell
      multiplyList :: Int -> [Int] -> [Int]
    #+END_SRC
    as
    #+BEGIN_SRC haskell
      multiplyList :: Int -> ([Int] -> [Int])
    #+END_SRC
    which is interprets multiplyList as a function that takes one integer
    arguments and evalutates to another function. THe function returned, then,
    takes a list of integers and returns another list of integers.
 
  - point-free style :: the definition style of functions with no argument
       variables

  *Note* All function in Haskell really take only one argument!

  - higher-order functions :: Functions like map which take other functions as arguments

  - Thanks to lazy evaluation, Haskell lists can be infinite since the callers only evaluates
    only up to what is needed.
    For example, both terminate in finite number of steps AND results to the same answer:
    scanSum( (takeInt 10 [1..]))
    (takeInt 10 (scanSum [1..]))
    
* Lists III
** List comprehensions
   - List comprehensions :: syntactic sugar for some common list operations such as filtering
     #+BEGIN_SRC haskell
retainEven es = [n | n <- es, isEven n]
     #+END_SRC
     interpretted as:
     - (starting from middle) :: take the list es and draw ( <- ) each of its elements as a value n
     - (after the comma) :: for each drawn n, test the boolean condition isEven
     - (before | ) :: if (and only if) the boolean condition is satistied, append n to the new list
                      being created (note the square brackets around the whole expression)

     thus is es is [1,2,3,4], then we would get back the list [2,3]. 1 and 3 fail the boolean hence not drawn
