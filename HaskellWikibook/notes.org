* Variables & Functions
  - Haskell variables are immutable
  - where :: when defining a function and want to define results that are
             local to the function
             #+BEGIN_SRC haskell
               heron a b c = sqrt (s * (s - a) * (s - b) * (s - c))
                 where
                   s = (a + b + c) / 2
             #+END_SRC
* Truth values
  - infix operators can be written as functions using brackes. The following
    expressions are equivalent
    #+BEGIN_SRC haskell
      4 + 9 === 13
      (==) (4 + 9) 13
    #+END_SRC
  - *in general, tangible things in Haskell are either values or functions*
** Guards
   syntactic sugar that relies on booleans values to write simple but powerful
   functions
   
   To define absolute value function:
   #+BEGIN_SRC haskell
     absolute x
       | x < 0     = 0 - x
       | otherwise = x
   #+END_SRC

   guards begin with a pipe character followed by a boolean expression followed
   by the rest of the definition.

   *Note* there is no syntactical magic begin 'otherwise'. It is defined
   alonside the default variables and functions of Haskell as
   #+BEGIN_SRC haskell
     otherwise = True
   #+END_SRC

** where and guards
   where clause works with guards.
   Consider a function which computes the number of (real) solutions for
   the quadratic equation
   #+BEGIN_SRC haskell
     numOfRealSolutions a b c
      | disc > 0  = 2
      | disc == 0 = 1
      | otherwise = 0
          where
          disc = b^2 - 4*a*c
   #+END_SRC
             
* Type basics
  - All types names in Haskell must begin with a capital letter
  - All variables in Haskell must begin with a lower case letter
  - :type :: to check the type of any expression

** Functional types
   Consider two things when figuring out a type of a function
   
   1) the type of values it takes as its input
   2) the type of values it returns
      
   Thus the description of a function's type is in terms of the types of
   argument(s) it takes and the type of value it evaluates to
      
* Lists and tuples
** Lists
  Haskell builds all lists by consing all elements to the empty list.
  [1,2,3,4,5] is equivalent to 1:2:3:4:5:[]

  the cons operator (:) must have a list as its second argument and
  all elements of the list must be of same type
** Tuples
   Tuples offer another way of storing multiple values in a single value.
   Key differences between tuples and lists:
   - Tuples have a fixed number of elements (immutable); you cannot cons a tuple.
     Makes sense to use tuples when knowing in advance how many values are to be stored.
     (i.e 2D coordinates of a point)
   - Elements of tuples need not be all of the same type.

     nomenclature: in general use n-tuple to denote a tuple of size n. 2-tuples are called pairs,
     3-tuples called triples, quadruples, quintuples, etc.

     tuples are handy when wanting to return more than one value froma function. 

     The type of a tuple is defined not only by its size but also the type of objects it contains. 
     For example, ("Hello", 32) and (47,"World") are fundamentally different since one is
     (String, Int) whereas other (Int, String). This difference in types means they cannot
     be put into a list.

** Retrieving values
   Standard functions for retrieving values from tuples (works only on pairs):
   fst :: (a,b) -> a
   snd :: (a,b) -> b

   Standard functions for retrieving values from lists):
   head :: [a] -> a
   tail :: [a] -> [a] -- get the list after the first value

   *Note* attempting to run head or tail on the empty list will crash a program


